<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>firstBlog | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.1 typeof的使用对一个值使用typeof 操作符可能返回下列某个字符串： “undefined”——如果这个值未定义； “boolean”——如果这个值是布尔值； “string”——如果这个值是字符串； “number”——如果这个值是数值； “object”——如果这个值是对象或null； “function”——如果这个值是函数。  1.2 Undefined对于尚未声明过的变量，">
<meta name="keywords" content="技术">
<meta property="og:type" content="article">
<meta property="og:title" content="firstBlog">
<meta property="og:url" content="http://yoursite.com/2017/09/08/firstBlog/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.1 typeof的使用对一个值使用typeof 操作符可能返回下列某个字符串： “undefined”——如果这个值未定义； “boolean”——如果这个值是布尔值； “string”——如果这个值是字符串； “number”——如果这个值是数值； “object”——如果这个值是对象或null； “function”——如果这个值是函数。  1.2 Undefined对于尚未声明过的变量，">
<meta property="og:updated_time" content="2017-09-08T14:25:25.600Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="firstBlog">
<meta name="twitter:description" content="1.1 typeof的使用对一个值使用typeof 操作符可能返回下列某个字符串： “undefined”——如果这个值未定义； “boolean”——如果这个值是布尔值； “string”——如果这个值是字符串； “number”——如果这个值是数值； “object”——如果这个值是对象或null； “function”——如果这个值是函数。  1.2 Undefined对于尚未声明过的变量，">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-firstBlog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/08/firstBlog/" class="article-date">
  <time datetime="2017-09-08T13:55:16.000Z" itemprop="datePublished">2017-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>►<a class="article-category-link" href="/categories/技术/Javascript/">Javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      firstBlog
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-1-typeof的使用"><a href="#1-1-typeof的使用" class="headerlink" title="1.1 typeof的使用"></a>1.1 typeof的使用</h3><h4 id="对一个值使用typeof-操作符可能返回下列某个字符串："><a href="#对一个值使用typeof-操作符可能返回下列某个字符串：" class="headerlink" title="对一个值使用typeof 操作符可能返回下列某个字符串："></a>对一个值使用typeof 操作符可能返回下列某个字符串：</h4><ul>
<li>“undefined”——如果这个值未定义；</li>
<li>“boolean”——如果这个值是布尔值；</li>
<li>“string”——如果这个值是字符串；</li>
<li>“number”——如果这个值是数值；</li>
<li>“object”——如果这个值是对象或null；</li>
<li>“function”——如果这个值是函数。</li>
</ul>
<h3 id="1-2-Undefined"><a href="#1-2-Undefined" class="headerlink" title="1.2 Undefined"></a>1.2 Undefined</h3><p>对于尚未声明过的变量，只能执行一项操作，即使用typeof 操作符检测其数据类型，而且！<strong>对未初始化的变量执行typeof 操作符会返回undefined 值，而对未声明的变量执行typeof 操作符同样也会返回undefined值。</strong></p>
<p>####<br>    var a;<br>    console.log(typeof a);//undefined<br>    console.log(typeof b);//undefined ,b 未定义，但返回值也是undefined</p>
<h3 id="1-3-Null"><a href="#1-3-Null" class="headerlink" title="1.3 Null"></a>1.3 Null</h3><p>从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用typeof 操作符检测null 值时会返回”object”的原因。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null 而不是其他值。undefined 值是派生自null 值的，因此ECMA-262 规定对它们的相等性测试要返回true。</p>
<p>####<br>    console.log(undefined==null);//true</p>
<h3 id="1-4-Boolean"><a href="#1-4-Boolean" class="headerlink" title="1.4 Boolean"></a>1.4 Boolean</h3><p>能转换成boolean的false的值：</p>
<p>####</p>
<ul>
<li>false</li>
<li>0</li>
<li>-0</li>
<li>undefined</li>
<li>null</li>
<li>NaN</li>
<li>“” (空字符串)</li>
</ul>
<h3 id="1-5-Number"><a href="#1-5-Number" class="headerlink" title="1.5 Number"></a>1.5 Number</h3><p>浮点数值的最高精度是17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加0.2的结果不是0.3，而是0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。</p>
<p>####<br>    if (a+b==0.3){<br>        console.log(“You got a 0.3”);//不要做这样的测试；<br>    }</p>
<h3 id="1-6-isNaN"><a href="#1-6-isNaN" class="headerlink" title="1.6 isNaN"></a>1.6 isNaN</h3><p>isNaN()在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串”10”或Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回true。</p>
<h3 id="1-7-String"><a href="#1-7-String" class="headerlink" title="1.7 String"></a>1.7 String</h3><p>String 类型用于表示由零或多个<strong>16 位Unicode 字符</strong>组成的字符序列，即字符串。</p>
<p>####</p>
<ul>
<li>字符字面量(转义序列)： \xnn 以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\x41表示”A”\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ<blockquote>
<p>这些字符字面量可以出现在字符串中的任意位置，而且也将被<strong>作为一个字符来解析</strong><br>####</p>
</blockquote>
</li>
<li>ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变<br>某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，例如：<br>####<br>  var lang=”Java”;<br>  lang=lang+”script”;<blockquote>
<p>以上示例中的变量lang 开始时包含字符串”Java”。而第二行代码把lang 的值重新定义为”Java”<br>与”Script”的组合，即”JavaScript”。实现这个操作的过程如下：首先创建一个能容纳10 个字符的<br>新字符串，然后在这个字符串中填充”Java”和”Script”，最后一步是销毁原来的字符串”Java”和字<br>符串”Script”，因为这两个字符串已经没用了。</p>
<h3 id="1-8-Object"><a href="#1-8-Object" class="headerlink" title="1.8 Object"></a>1.8 Object</h3><p>在ECMAScript 中，(就像Java 中的java.lang.Object 对象一样）Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。</p>
<h3 id="1-9-amp-amp-逻辑与操作符"><a href="#1-9-amp-amp-逻辑与操作符" class="headerlink" title="1.9 &amp;&amp; 逻辑与操作符"></a>1.9 &amp;&amp; 逻辑与操作符</h3><p>逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。<br>对于逻辑与操作而言，如果第一个操作数是false，则无论第二个操作数是什么值，结果都不再可能是<br>true 了。如下例子所示：<br>####<br>  var found = true;<br>  var result= (found &amp;&amp; a);//这里会发生错误，因为found为true，则会对a求值，a却未定义</p>
<pre><code>//，所以会报错
</code></pre><p>  console.log(result);    //不会执行。<br>若改为如下代码则可以<br>####<br>  var found = false;<br>  var result= (found &amp;&amp; a);//这里不会发生错误，因为found为false，则不会对a求值，即使</p>
<pre><code>//a未定义，也不会报错
</code></pre><p>  console.log(result);    //会执行。</p>
<h3 id="1-10-逻辑非操作符"><a href="#1-10-逻辑非操作符" class="headerlink" title="1.10 || 逻辑非操作符"></a>1.10 || 逻辑非操作符</h3><p>与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。<br><br>我们可以利用逻辑或的这一行为来避免为变量赋null 或undefined 值。例如：<br>####<br>  var myObject = preferredObject || backupObject;<br>在这个例子中，变量myObject 将被赋予等号后面两个值中的一个。变量preferredObject 中包<br>含优先赋给变量myObject 的值，变量backupObject 负责在preferredObject 中不包含有效值的情况下提供后备值。如果preferredObject 的值不是null，那么它的值将被赋给myObject；如果<br>是null，则将backupObject 的值赋给myObject。</p>
</blockquote>
</li>
</ul>
<h3 id="1-11-this对象"><a href="#1-11-this对象" class="headerlink" title="1.11 this对象"></a>1.11 this对象</h3><pre><code>var name = &quot;The Window&quot;;
object = {
name : &quot;My Object&quot;,
getName: function(){
    return this.name;
}
};
(object.getName)(); //&quot;My Object&quot;
(object.getName = object.getName)(); //&quot;The Window&quot;，在非严格模式下
</code></pre><blockquote>
<p><strong>第二行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是<br>函数本身，所以this 的值不能得到维持，结果就返回了”The Window”。</strong></p>
<h3 id="1-12-内存泄漏"><a href="#1-12-内存泄漏" class="headerlink" title="1.12 内存泄漏"></a>1.12 内存泄漏</h3><ul>
<li>具体来说，如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁。来看下面的例子<br>####<br>  function assignHandler(){<pre><code>var element = document.getElementById(&quot;someElement&quot;);
element.onclick = function(){
alert(element.id);
};
</code></pre>  }<br>以上代码创建了一个作为element 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引<br>用（事件将在第13 章讨论）。由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此<br>就会导致无法减少element 的引用数。只要匿名函数存在，element 的引用数至少也是1，因此它所<br>占用的内存就永远不会被回收。不过，这个问题可以通过稍微改写一下代码来解决，如下所示。<br>####<br>  function assignHandler(){<pre><code>var element = document.getElementById(&quot;someElement&quot;);
var id = element.id;
element.onclick = function(){
alert(id);
};
element = null;
</code></pre>  }<br>在上面的代码中，通过把element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消<br>除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数<br>的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也<br>仍然会保存一个引用。因此，有必要把element 变量设置为null。这样就能够解除对DOM 对象的引<br>用，顺利地减少其引用数，确保正常回收其占用的内存。</li>
</ul>
</blockquote>
<h3 id="1-13-对数组调用toString-和valueOf-方法"><a href="#1-13-对数组调用toString-和valueOf-方法" class="headerlink" title="1.13 对数组调用toString()和valueOf()方法"></a>1.13 对数组调用toString()和valueOf()方法</h3><pre><code>var arr2 = [100, true, &apos;Joey&apos;];
console.log(arr2.toString());//100,true,Joey
console.log(arr2.toLocaleString());//100,true,Joey
console.log(arr2.valueOf());//[100, true, &quot;Joey&quot;]
console.log(arr2);//[100, true, &quot;Joey&quot;]
</code></pre><h3 id="1-14-数组的遍历方法"><a href="#1-14-数组的遍历方法" class="headerlink" title="1.14 数组的遍历方法"></a>1.14 数组的遍历方法</h3><p>ECMAScript 5 为数组定义了5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this 的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。</p>
<ul>
<li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。</li>
<li>filter()：对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li><p>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</p>
<pre><code>var numbers = [1,2,3,4,5,4,3,2,1];
var everyResult = numbers.every(function(item, index, array){
    return (item &gt; 2);
});
alert(everyResult); //false
var someResult = numbers.some(function(item, index, array){
    return (item &gt; 2);
});
alert(someResult); //true
</code></pre></li>
</ul>
<h3 id="1-15-函数的arguments的callee属性"><a href="#1-15-函数的arguments的callee属性" class="headerlink" title="1.15 函数的arguments的callee属性"></a>1.15 函数的arguments的callee属性</h3><ul>
<li><p>函数的arguments的callee属性指向拥有arguments的函数，即这个函数；</p>
<pre><code>function factorial(num) {
    if (num &lt;= 1) {
        return 1;
    } else {
        //通过arguments的callee属性指向拥有arguments的函数；
        return num * arguments.callee(num - 1);
    }
    }
console.log(factorial(5));//输出120
</code></pre></li>
</ul>
<h3 id="1-16-函数的apply-和call-方法"><a href="#1-16-函数的apply-和call-方法" class="headerlink" title="1.16 函数的apply()和call()方法"></a>1.16 函数的apply()和call()方法</h3><ul>
<li><p>apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this 对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array 的实例，也可以是arguments 对象。</p>
<pre><code>window.color = &quot;red&quot;;
var o = { color: &quot;blue&quot; };
function sayColor() {
    alert(this.color);
}
sayColor(); //red，在全局环境中调用，this指向window；
sayColor.call(this); //red，此时this即是保姆；
sayColor.call(window); //red
sayColor.call(o); //blue，更改环境变量为o；
</code></pre></li>
</ul>
<h3 id="1-17-函数的bind-方法"><a href="#1-17-函数的bind-方法" class="headerlink" title="1.17 函数的bind()方法"></a>1.17 函数的bind()方法</h3><ul>
<li><p>bind()这个方法会创建一个函数的实例，其this 值会被绑定到传给bind()函数的值。</p>
<pre><code>window.color = &quot;red&quot;;
var o = { color: &quot;blue&quot; };
function sayColor(){
    alert(this.color);
}
var objectSayColor = sayColor.bind(o);
objectSayColor(); //blue
</code></pre></li>
</ul>
<blockquote>
<p>在这里，sayColor()调用bind()并传入对象o，创建了objectSayColor()函数。object-SayColor()函数的this 值等于o，因此即使是在全局作用域中调用这个函数，也会看到”blue”。其作用域对象是o，但并不是o的方法。</p>
</blockquote>
<h3 id="1-18创建对象的方法："><a href="#1-18创建对象的方法：" class="headerlink" title="1.18创建对象的方法："></a>1.18创建对象的方法：</h3><ol>
<li><p>创建一个Object构造函数的实例；</p>
<pre><code>var obj=new Object();
</code></pre></li>
<li><p>使用字面量的方法：</p>
<pre><code>var obj={};
</code></pre></li>
<li><p>使用工厂模式（函数模式批量生产）：</p>
<pre><code>function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o;
}
var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
</code></pre></li>
<li><p>构造函数模式：</p>
<pre><code>function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    };
}
var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
</code></pre><blockquote>
<p>任何函数，只要通过new 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过new 操作符来调用，那它跟普通函数也不会有什么两样。例如：</p>
</blockquote>
<pre><code>// 当作构造函数使用
var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
person.sayName(); //&quot;Nicholas&quot;
// 作为普通函数调用
Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); // 添加到window
window.sayName(); //&quot;Greg&quot;
// 在另一个对象的作用域中调用
var o = new Object();
Person.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;);
o.sayName(); //&quot;Kristen&quot;
ConstructorPatternExample02
</code></pre></li>
</ol>
<blockquote>
<p>不使用new 操作符调用Person()会出现什么结果：属性和方法都被添加给window对象了，因为，当在全局作用域中调用一个函数时，this 对象总是指向Global 对象（在浏览器中就是window 对象）。最后，也可以使用call()（或者apply()）在某个特殊对象的作用域中调用Person()函数。这里是在对象o 的作用域中调用的，因此调用后o 就拥有了所有属性和sayName()方法。</p>
</blockquote>
<ol>
<li>原型方法：<blockquote>
<p>详见原型链图；</p>
</blockquote>
</li>
</ol>
<p>5.1 原型与in操作符：<br>有两种方式使用in 操作符：单独使用和在for-in 循环中使用。</p>
<ul>
<li>在单独使用时，in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</li>
<li>forin循环</li>
</ul>
<ol>
<li><p>组合使用构造函数模式和原型模式</p>
<pre><code>function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];
}
Person.prototype = {
    constructor : Person,
    sayName : function(){
        alert(this.name);
    }
}
var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
person1.friends.push(&quot;Van&quot;);
alert(person1.friends); //&quot;Shelby,Count,Van&quot;
alert(person2.friends); //&quot;Shelby,Count&quot;
alert(person1.friends === person2.friends); //false
alert(person1.sayName === person2.sayName); //true
</code></pre></li>
<li><p>动态原型模式</p>
<pre><code>function Person(name, age, job){
    //属性
    this.name = name;
    this.age = age;
    this.job = job;
    //方法
    if (typeof this.sayName != &quot;function&quot;){
        Person.prototype.sayName = function(){
            alert(this.name);
        };
    }
}
var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
friend.sayName();
</code></pre></li>
</ol>
<blockquote>
<p>注意构造函数代码中加粗的部分。这里只在sayName()方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可以说非常完美。其中，if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使用instanceof 操作符确定它的类型。</p>
</blockquote>
<h3 id="1-19-继承"><a href="#1-19-继承" class="headerlink" title="1.19 继承"></a>1.19 继承</h3><ol>
<li><p>通过原型链继承</p>
<pre><code>A.prototype=new B();
</code></pre></li>
<li><p>借用构造函数</p>
<pre><code>function SuperType(){
    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
}
function SubType(){
    //继承了SuperType
    SuperType.call(this);
}
var instance1 = new SubType();
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors); //&quot;red,blue,green,black&quot;
var instance2 = new SubType();
alert(instance2.colors); //&quot;red,blue,green&quot;
</code></pre></li>
<li><p>组合继承</p>
<blockquote>
<p>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
</blockquote>
<pre><code>function SuperType(name){
    this.name = name;
    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
}
SuperType.prototype.sayName = function(){
    alert(this.name);
};
function SubType(name, age){
    //继承属性
    SuperType.call(this, name);
    this.age = age;
}
//继承方法
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function(){
    alert(this.age);
};
var instance1 = new SubType(&quot;Nicholas&quot;, 29);
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors); //&quot;red,blue,green,black&quot;
instance1.sayName(); //&quot;Nicholas&quot;;
instance1.sayAge(); //29
var instance2 = new SubType(&quot;Greg&quot;, 27);
alert(instance2.colors); //&quot;red,blue,green&quot;
instance2.sayName(); //&quot;Greg&quot;;
instance2.sayAge(); //27
</code></pre></li>
<li><p>原型式继承</p>
<pre><code>//借助原型可以基于已有的对象创建新对象,其函数如下
function object(o) {
        function F() { }
        F.prototype = o;
        return new F();
}

//原型式继承实例如下：
function object(o) {
        function F() { }
        F.prototype = o;
        return new F();
    }
    var person = {
        name: &quot;Nicholas&quot;,
        friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]
    };
    var anotherPerson = object(person);
    anotherPerson.name = &quot;Greg&quot;;
    anotherPerson.friends.push(&quot;Rob&quot;);
    var yetAnotherPerson = object(person);
    yetAnotherPerson.name = &quot;Linda&quot;;
    yetAnotherPerson.friends.push(&quot;Barbie&quot;);
    console.log(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot;
</code></pre></li>
<li><p>寄生式继承</p>
<pre><code>function object(o) {
    function F() { }
    F.prototype = o;
    return new F();
}
function createAnother(original){
var clone = object(original); //通过调用函数创建一个新对象
clone.sayHi = function(){ //以某种方式来增强这个对象
alert(&quot;hi&quot;);
};
return clone; //返回这个对象
}
var person = {
name: &quot;Nicholas&quot;,
friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi(); //&quot;hi&quot;
</code></pre></li>
<li><p>寄生式组合继承</p>
<pre><code>function object(o) {
    function F() { }
    F.prototype = o;
    return new F();
}
function inheritPrototype(subType, superType){
    var prototype = object(superType.prototype); //创建对象
    prototype.constructor = subType; //增强对象
    subType.prototype = prototype; //指定对象
}
function SuperType(name){
    this.name = name;
    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
}
SuperType.prototype.sayName = function(){
    alert(this.name);
};
function SubType(name, age){
    SuperType.call(this, name);
    this.age = age;
}
inheritPrototype(SubType, SuperType);
SubType.prototype.sayAge = function(){
    alert(this.age);
};
</code></pre></li>
</ol>
<blockquote>
<p><strong>寄生组合式继承是引用类型最理想的继承范式！！！</strong></p>
</blockquote>
<h3 id="1-20-闭包"><a href="#1-20-闭包" class="headerlink" title="1.20 闭包"></a>1.20 闭包</h3><p><strong>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数，</strong></p>
<pre><code>function createComparisonFunction(propertyName) {
    return function(object1, object2){
        var value1 = object1[propertyName];
        var value2 = object2[propertyName];
        if (value1 &lt; value2){
            return -1;
        } else if (value1 &gt; value2){
            return 1;
        } else {
            return 0;
        }
    };
}
</code></pre><blockquote>
<p><strong>如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁。</strong></p>
</blockquote>
<pre><code>function assignHandler(){
    var element = document.getElementById(&quot;someElement&quot;);
    element.onclick = function(){
        alert(element.id);
    };
}
</code></pre><blockquote>
<p>以上代码创建了一个作为element 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用（事件将在第13 章讨论）。由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element 的引用数。只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收。不过，这个问题可以通过稍微改写一下代码来解决，如下所示。</p>
</blockquote>
<pre><code>function assignHandler(){
    var element = document.getElementById(&quot;someElement&quot;);
    var id = element.id;
    element.onclick = function(){
        alert(id);
    };
    element = null;
}
</code></pre><blockquote>
<p>在上面的代码中，通过把element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把element 变量设置为null。这样就能够解除对DOM 对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。</p>
</blockquote>
<h3 id="1-21-模仿块级作用域"><a href="#1-21-模仿块级作用域" class="headerlink" title="1.21 模仿块级作用域"></a>1.21 模仿块级作用域</h3><p>JavaScript 没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的。</p>
<pre><code>function outputNumbers(count){
    for (var i=0; i &lt; count; i++){
        alert(i);
    }
    var i; //重新声明变量
    alert(i); //计数
}
</code></pre><blockquote>
<p><strong>JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）</strong></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/08/firstBlog/" data-id="cj7by1vno0000fku0nxuflwq1" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/09/08/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Javascript/">Javascript</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/技术/" style="font-size: 10px;">技术</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/08/firstBlog/">firstBlog</a>
          </li>
        
          <li>
            <a href="/2017/09/08/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>